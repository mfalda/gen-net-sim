\name{simulateprofiles}
\alias{simulateprofiles}
\title{Simulator of time-series gene expression data}
\description{The algorithm generates gene expression data from given topology, regulatory rules and kinetic parameters.}
\usage{
Data.new<-simulateprofiles<-function(weights, Rules=list(), f.pr.and="", act.fun="sigmoidal",alpha=c(10,0.2), beta=c(0.5,0.01), lambda=c(1,0.1), Xmin=NULL, Xmax=NULL, X0=c(0,1), params=c(2,2,2,0,0,1), ko.experim=NULL, times=seq(0,5,0.05), stat_thr=0.001, stat_width=0, sd_noise=NULL, method="rkf45", EXT.IN=NA, EXT.FUN=list(), itera=1, save=FALSE)
}
\arguments{
  \item{weights}{Adjacence matrix defining network topology: an element (i,j) different from 0 indicates that j regulates i. Absolute value and sign of each element indicate efficiency and sign of the regulation. If NULL all networks in the current directory are processed}
  \item{Rules}{Either an empty list (functions defining interaction among regulators are automatically generated), NULL (the rules generated by simulatenet are considered) or a list codifying, for each element i, the interactions among the regulators of gene i. See details.}
  \item{f.pr.and}{Function with domain and codomain in [0-1] that expresses the probability to obtain a cooperative rather than a synergic rule as a function of the level of the binary tree used to implement the interactions among the regulators. Given a binary tree of maximum L levels, the probability to have a cooperative rule at level i is f.pr.and(i/L), whereas the probability to have a synergic rule is 1-f.pr.and(i/L). See details}
  \item{act.fun}{The activation function: either "linear", i.e. the target function resulting from regulatory rules or "sigmoidal", i.e. the modulated target function (see References for further details). Default="sigmoidal"}
  \item{alpha}{Vector of parameters of the Activation sigmoid function. If NULL, alpha is set equal to rnorm(1,10,0.2) for each gene.}
  \item{beta}{Vector of parameters of the Activation sigmoid function. If NULL, alpha is set equal to rnorm(1,0.5,0.01) for each gene.}
  \item{lambda}{vector of time constants influencing both the rate of transcription and the spontaneous degra-dation term for each gene i. }
  \item{Xmin}{vector of minimum level of expression of genes. If NULL, Xmin is set equal to rep(0,N).}
  \item{Xmax}{vector of maximum level of expression of genes. If NULL, Xmax is set equal to rep(10,N).}
  \item{X0}{Initial conditions, i.e. gene expression values at time 0 scaled between 0 and 1. If NULL, x0 is set equal to runif(1,0,1) for each node i.}
  \item{params}{A vector identifying the type of distribution for input parameters lambda, alpha, beta, Xmin, Xmax and X0; 0 stands for "external", 1 for "uniform", 2 for "normal" and 3 for "log-normal", 4 for files generated from simulatenet; the last element can assume only values 0, 1 or 4. Default=c(2,2,2,0,0,1)}
  \item{times}{Time samples at which explicit estimates of gene expression are desired. The first value must be 0. Default=seq(0,5,0.05)}
   \item{stat_thr}{the absolute difference between consecutive points in the generated profiles that, when satisfied by all the profiles, allows to consider the solution in a stationary point. Default=0.001}
   \item{stat_width}{the percentage of consecutive sampling times during which the "stat_thr" threshold has to be satisfied in order to consider the solution in a stationary point. Default=0}
  \item{ko.experim}{A vector identifying the genes on which perform knock-out; 0 for all, NULL for none. Default=NULL}
	\item{sd_noise}{if different from NULL, Gaussian noise (mean=0, sd=sd_noise) is added at each time step. sd_noise must be at minimum 0.25; it will be added to normalized expression data (between 0 and 1). Default is NULL}
  \item{method}{One among "Euler", "rkf45", "rkrk", "rk8pd", "rk2imp", "rk4imp", "gear1", "gear2". Method used to solve differential equations. Either the Euler method or one of the GNU Scientific Library ODE solvers. Default="rkf45"}
  \item{EXT.IN}{Adjacence matrix containing parameters of sign and efficiency of regulation of external inputs on genes. It must have N rows, with N=number of nodes in the network and a number of coloumns equal to the number of external inputs. If equal to NA (default), no external input effect is considered.}
  \item{EXT.FUN}{List of functions describing the external input signal as a function of time. If equal to an empty list (default), no external input effect is considered.}
   \item{itera}{number of iterations. Default=1}
  \item{save}{If TRUE the connectivity matrix, the generated expression profiles, the regulatory rules and a matrix with parameters lambda, alpha, beta, Xmin, Xmax and X0 are saved. Default=FALSE}
  }

\details{The algorithm, generate gene expression data given topology and, possibly, regulatory rules and kinetic
parameters. See \code{\link{simulatenet}} from further details.

GENERATION OF RANDOM INTERACTIONS AMONG REGULATORS

For each gene i, the interactions among its regulators are codified in position  [[i]] of the list "Rules" as a vector representing a binary tree.
In particular, the root of the tree has position 1 in the vector and for every node of the tree in position i, the left son has position 2*i and the right son has position 2*i+1
If a node corresponds to a regulator, it becomes a leaf; therefore, the maximum number of levels that the tree can have corresponds to the number of regulators.
Functions and regulators can be positioned anywhere on the tree, with the only constraint that regulators must have a function as parent node, so, for example,
the root of the tree is always a function, unless there is a single regulator; in this case the tree collapses in a single node corresponding to the regulator.
Only fCOOPERATIVE and fSYNERGIC are used as function nodes
\itemize{
\item{The COOPERATIVE rule is codified by -2}
\item{The SYNERGIC rule is codified by -3}
\item{The regulatory genes are codified by their index (i.e. an integer ranging from 1 to N).}
\item{The empty node by a -1}
}
For example,
\itemize{
\item{the rule fCOOPERATIVE(fSYNERGIC(x1,x2), fCOOPERATIVE(x3,x4)) is codified by the vector v=c(-2,-3,-2,1,2,3,4)}
\item{the rule fCOOPERATIVE(fSYNERGIC(x1,x2), fCOOPERATIVE(fCOOPERATIVE(x3,x5),x4)) is codified by the vector v=c(-2,-3,-2,1,2,-2,4,-1,-1,-1,-1,3,5,-1,-1)}
}
The COMPETITIVE and NEGATIVE rules are obtained by combining the SYNERGIC and COOPERATIVE rules with the sign of the adjacence matrix parameters
COOPERATIVE functions having as argument regulators of different sign (one activator and one inhibitor) are transformed in COMPETITIVE functions, i.e. fCOOPERATIVE(x1,-x2)=fCOMPETITIVE(x1,x2),
whereas if both regulators are negative, the NEGATIVEe effect of a COOPERATIVE action is considered,
i.e. fCOOPERATIVE(-x1,-x2)=fNEGATIVE(fCOOPERATIVE(x1,x2)).
The NEGATIVE regulatory action of a regulator being argument of a SYNERGIC function is always considered
as a fNEGATIVE, e.g. fSYNERGIC(x1,-x2)=fSYNERGIC(x1,fNEGATIVE(x2)).

If Rules=NULL, interaction rules are randomly generated, by randomly assigning fSYNERGIC and fCOOPERATIVE rules
In particular, if f.pr.and=NULL, the probability to have a cooperative or a synergic function is the same (50%).
Alternatively, it is possible to assign f.pr.and a function with domain and codomain in [0-1], which expresses the probability
to obtain a cooperative rather than a synergic rule as a function of the level of the binary tree used to implement the interactions among the regulators.
Given a binary tree of maximum L levels, the probability to have a cooperative rule at level i is f.pr.and(i/L),
whereas the probability to have a synergic rule is 1-f.pr.and(i/L).
Examples of suitable functions are:
f1<-function(x) {y<-1/(1+_e(-10*(x-0.5))); return(y)} where x=i/L (probability to have a cooperative function increases with the tree level)
or
f1<-function(x) {y<-0.8; return(y)} where x=i/L (probability to have a cooperative function is constant)

Example of code that implements the network response to an external input sin(t) influencing genes 2 and 3 and an external input ramp function influencing gene 2 are given below. For sake of simplicity, all regulatory efficiencies are assumed equal to 1

}

\value{The function returns the matrix of gene expression data with genes in rows and time-samples in coloumns.}

\author{
  Barbara Di Camillo
}


\references{
  \enumerate{
\item{Barbara Di Camillo, Gianna Toffolo, Claudio Cobelli. A Gene Network Simulator to Assess Reverse Engineering Algorithms.
  \emph{NYAS} \bold{Submitted}.}
\item{Barbara Di Camillo, Gianna Toffolo, Claudio Cobelli. A gene network simulator integrating Boolean regulation in a continuous dynamic model
  \emph{5th European Conference on Computational Biology - ECCB '06} \bold{Eilat, Israel, January 20-24, 2007}.}
  }
}

\seealso{\code{\link{simulatenet}} : a simulator that generates network topology, regulatory rules and expression profiles, according to the parameter settings given as input.}

\examples{
net<-simulatenet(N=50,connectivity="MTM",act.fun="sigmoidal", method="rkf45")
Data<-net[[1]][[1]]
W.matrix<-net[[1]][[2]]
R<-net[[2]]
param.lambda<-net[[1]][[3]]
param.alpha<-net[[1]][[4]]
param.beta<-net[[1]][[5]]
N<-dim(Data)[1]
baseline<-runif(N,0,1)
Data.new<-simulateprofiles(X0=baseline,Xmax=rep(10,N),lambda=param.lambda,weights=W.matrix,Rules=R,act.fun="sigmoidal",alpha=param.alpha, beta=param.beta, method="rkf45")

f1<-"sin(t)"
f2<-"(t<1)? 0 : -t-1"
ext.W<-matrix(0,N,2)
ext.W[2,1]<-ext.W[3,1]<-ext.W[2,2]<-1
Data.new<-simulateprofiles(X0=baseline,Xmax=rep(10,N),lambda=param.lambda,weights=W.matrix,Rules=R,act.fun="sigmoidal",alpha=param.alpha, beta=param.beta, method="rkf45", EXT.IN=ext.W, EXT.FUN=list(f1, f2))

}

\keyword{datagen}
\keyword{ts}

